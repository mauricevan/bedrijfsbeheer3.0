import { useState, useCallback } from "react";
import type {
  Invoice,
  Customer,
  Employee,
  User,
  WorkOrder,
  InventoryItem,
  ModuleKey,
} from "../../../types";
import { trackAction } from "../../../utils/analytics";
import { useInvoiceForm } from "./useInvoiceForm";
import {
  createInvoice,
  updateInvoice,
  updateInvoiceStatus as updateInvoiceStatusService,
  deleteInvoice as deleteInvoiceService,
  cloneInvoice,
  syncInvoiceToWorkOrder as syncInvoiceToWorkOrderService,
  sendInvoiceReminder,
  shouldShowValidationModal,
} from "../services/invoiceService";
import { createInvoiceSentNotification } from "../../../utils/smartNotifications";
import {
  isAutoGeneratedInvoice,
  createHistoryEntry,
  getEmployeeName,
} from "../utils/helpers";
import type { InvoiceHistoryEntry } from "../../../types";

/**
 * Hook for managing invoices state and operations
 * @param invoices - Invoices array
 * @param setInvoices - Function to update invoices
 * @param inventory - Array of inventory items (for invoice form)
 * @param customers - Array of customers
 * @param employees - Array of employees
 * @param currentUser - Current user
 * @param workOrders - Array of work orders (for syncing)
 * @param setWorkOrders - Function to update work orders
 * @param setNotifications - Optional function to update notifications
 * @returns Invoices state and handlers
 */
export const useInvoices = (
  invoices: Invoice[],
  setInvoices: React.Dispatch<React.SetStateAction<Invoice[]>>,
  inventory: InventoryItem[],
  customers: Customer[],
  employees: Employee[],
  currentUser: User,
  workOrders: WorkOrder[],
  setWorkOrders: React.Dispatch<React.SetStateAction<WorkOrder[]>>,
  setNotifications?: React.Dispatch<React.SetStateAction<any[]>>
) => {
  const [showInvoiceForm, setShowInvoiceForm] = useState(false);
  const [showCloneInvoiceModal, setShowCloneInvoiceModal] = useState(false);
  const [showInvoiceValidationModal, setShowInvoiceValidationModal] =
    useState(false);
  const [invoiceToValidate, setInvoiceToValidate] = useState<Invoice | null>(
    null
  );
  const [validationChecklist, setValidationChecklist] = useState({
    hoursChecked: false,
    materialsChecked: false,
    extraWorkAdded: false,
  });

  // Use invoice form hook
  const invoiceForm = useInvoiceForm(inventory);

  /**
   * Generate invoice number
   */
  const generateInvoiceNumber = useCallback(() => {
    const year = new Date().getFullYear();
    const existingNumbers = invoices
      .filter((inv) => inv.invoiceNumber.startsWith(`INV-${year}-`))
      .map((inv) => {
        const parts = inv.invoiceNumber.split("-");
        return parseInt(parts[parts.length - 1], 10);
      });

    const nextNumber = existingNumbers.length > 0 
      ? Math.max(...existingNumbers) + 1 
      : 1;

    return `INV-${year}-${nextNumber.toString().padStart(4, "0")}`;
  }, [invoices]);

  /**
   * Create a new invoice
   */
  const createInvoiceHandler = useCallback(() => {
    try {
      // Validate form
      if (!invoiceForm.validate()) {
        alert(invoiceForm.errors._form || "Vul alle verplichte velden in!");
        return;
      }

      // If editing, update existing invoice
      if (invoiceForm.editingInvoiceId) {
        const existingInvoice = invoices.find(
          (inv) => inv.id === invoiceForm.editingInvoiceId
        );
        if (!existingInvoice) return;

        const updatedInvoice = updateInvoice(
          invoiceForm.editingInvoiceId,
          {
            customerId: invoiceForm.formData.customerId,
            items: invoiceForm.formData.items,
            labor: invoiceForm.formData.labor,
            vatRate: invoiceForm.formData.vatRate,
            notes: invoiceForm.formData.notes,
            paymentTerms: invoiceForm.formData.paymentTerms,
            issueDate: invoiceForm.formData.issueDate,
            dueDate: invoiceForm.formData.dueDate,
          },
          existingInvoice,
          currentUser,
          employees
        );

        setInvoices(
          invoices.map((inv) =>
            inv.id === invoiceForm.editingInvoiceId ? updatedInvoice : inv
          )
        );

        // Sync to workorder if exists
        if (updatedInvoice.workOrderId) {
          const workOrder = workOrders.find(
            (wo) => wo.id === updatedInvoice.workOrderId
          );
          if (workOrder) {
            const synced = syncInvoiceToWorkOrderService(
              updatedInvoice,
              workOrder
            );
            if (synced) {
              setWorkOrders(
                workOrders.map((wo) => (wo.id === workOrder.id ? synced : wo))
              );
              alert("✅ Factuur en werkorder succesvol gesynchroniseerd!");
            }
          }
        }

        invoiceForm.reset();
        setShowInvoiceForm(false);
        alert(`✅ Factuur ${updatedInvoice.invoiceNumber} succesvol bijgewerkt!`);
        return;
      }

      // Create new invoice
      const invoice = createInvoice(
        {
          customerId: invoiceForm.formData.customerId,
          items: invoiceForm.formData.items,
          labor: invoiceForm.formData.labor,
          vatRate: invoiceForm.formData.vatRate,
          notes: invoiceForm.formData.notes,
          paymentTerms: invoiceForm.formData.paymentTerms,
          issueDate: invoiceForm.formData.issueDate,
          dueDate: invoiceForm.formData.dueDate,
        },
        currentUser,
        employees,
        customers,
        invoices,
        generateInvoiceNumber()
      );

      setInvoices([...invoices, invoice]);
      invoiceForm.reset();
      setShowInvoiceForm(false);

      // Track analytics
      trackAction(
        currentUser.employeeId,
        currentUser.role,
        ModuleKey.ACCOUNTING,
        "create_invoice",
        "create",
        {
          invoiceId: invoice.id,
          invoiceNumber: invoice.invoiceNumber,
          customerId: invoice.customerId,
          total: invoice.total,
          itemsCount: invoice.items.length,
          laborCount: invoice.labor?.length || 0,
        }
      );
      alert(`✅ Factuur ${invoice.invoiceNumber} succesvol aangemaakt!`);
    } catch (error) {
      alert((error as Error).message || "Er is een fout opgetreden!");
    }
  }, [
    invoiceForm,
    invoices,
    customers,
    employees,
    currentUser,
    workOrders,
    setWorkOrders,
    generateInvoiceNumber,
  ]);

  /**
   * Edit an invoice
   */
  const editInvoice = useCallback(
    (invoiceId: string) => {
      const invoice = invoices.find((inv) => inv.id === invoiceId);
      if (!invoice) return;

      // Pre-fill form with invoice data using hook
      invoiceForm.loadInvoiceForEditing({
        customerId: invoice.customerId,
        items: invoice.items,
        labor: invoice.labor || [],
        vatRate: invoice.vatRate,
        notes: invoice.notes || "",
        paymentTerms: invoice.paymentTerms || "14 dagen",
        issueDate: invoice.issueDate,
        dueDate: invoice.dueDate,
      });

      // Store editing invoice ID
      invoiceForm.setEditingInvoiceId(invoiceId);

      // Open form
      setShowInvoiceForm(true);
    },
    [invoices, invoiceForm]
  );

  /**
   * Update invoice status
   */
  const updateInvoiceStatus = useCallback(
    (invoiceId: string, newStatus: Invoice["status"]) => {
      const invoice = invoices.find((inv) => inv.id === invoiceId);
      if (!invoice) return;

      const updatedInvoice = updateInvoiceStatusService(
        invoice,
        newStatus,
        currentUser,
        employees
      );

      setInvoices(
        invoices.map((inv) => (inv.id === invoiceId ? updatedInvoice : inv))
      );

      // Auto-sync to workorder if status changes
      if (updatedInvoice.workOrderId && newStatus === "paid") {
        const workOrder = workOrders.find(
          (wo) => wo.id === updatedInvoice.workOrderId
        );
        if (workOrder) {
          const synced = syncInvoiceToWorkOrderService(
            updatedInvoice,
            workOrder
          );
          if (synced) {
            setWorkOrders(
              workOrders.map((wo) => (wo.id === workOrder.id ? synced : wo))
            );
          }
        }
      }
    },
    [invoices, currentUser, employees, workOrders, setWorkOrders]
  );

  /**
   * Delete an invoice
   */
  const deleteInvoice = useCallback(
    (invoiceId: string) => {
      if (confirm("Weet je zeker dat je deze factuur wilt verwijderen?")) {
        const filteredInvoices = deleteInvoiceService(invoiceId, invoices);
        setInvoices(filteredInvoices);
      }
    },
    [invoices, setInvoices]
  );

  /**
   * Clone an invoice
   */
  const cloneInvoiceHandler = useCallback(
    (invoiceId: string) => {
      const invoice = invoices.find((inv) => inv.id === invoiceId);
      if (!invoice) return;

      // Prepare clone data with new ID and reset fields using hook
      invoiceForm.setFields({
        customerId: invoice.customerId,
        items: invoice.items,
        labor: invoice.labor || [],
        vatRate: invoice.vatRate,
        notes: invoice.notes || "",
        paymentTerms: invoice.paymentTerms || "14 dagen",
        issueDate: "",
        dueDate: "",
      });
      setShowCloneInvoiceModal(true);
    },
    [invoices, invoiceForm]
  );

  /**
   * Save cloned invoice
   */
  const saveClonedInvoice = useCallback(
    (sendToWorkOrder: boolean = false) => {
      // Find the original invoice being cloned
      const originalInvoiceId = invoices.find(
        (inv) =>
          inv.customerId === invoiceForm.formData.customerId &&
          JSON.stringify(inv.items) ===
            JSON.stringify(invoiceForm.formData.items)
      )?.id;

      if (!originalInvoiceId) {
        // If no original found, create as new invoice
        createInvoiceHandler();
        return;
      }

      const originalInvoice = invoices.find(
        (inv) => inv.id === originalInvoiceId
      );
      if (!originalInvoice) {
        createInvoiceHandler();
        return;
      }

      try {
        const clonedInvoice = cloneInvoice(
          originalInvoice,
          currentUser,
          employees,
          customers,
          generateInvoiceNumber()
        );

        // Override with form data
        clonedInvoice.issueDate = invoiceForm.formData.issueDate;
        clonedInvoice.dueDate = invoiceForm.formData.dueDate;
        clonedInvoice.notes = invoiceForm.formData.notes;

        setInvoices([...invoices, clonedInvoice]);
        invoiceForm.reset();
        setShowCloneInvoiceModal(false);

        if (sendToWorkOrder) {
          // This will be handled by the parent component
          return clonedInvoice;
        } else {
          alert(`✅ Factuur ${clonedInvoice.invoiceNumber} succesvol gecloneerd!`);

          // Scroll to the new invoice
          setTimeout(() => {
            const element = document.getElementById(clonedInvoice.id);
            element?.scrollIntoView({ behavior: "smooth", block: "center" });
          }, 100);
        }
      } catch (error) {
        alert((error as Error).message || "Er is een fout opgetreden!");
      }
    },
    [
      invoices,
      invoiceForm,
      currentUser,
      employees,
      customers,
      generateInvoiceNumber,
      createInvoiceHandler,
    ]
  );

  /**
   * Send invoice reminder
   */
  const sendReminder = useCallback(
    (invoiceId: string, reminderNumber: 1 | 2) => {
      const invoice = invoices.find((inv) => inv.id === invoiceId);
      if (!invoice) return;

      const updatedInvoice = sendInvoiceReminder(
        invoice,
        reminderNumber,
        currentUser,
        employees
      );

      setInvoices(
        invoices.map((inv) => (inv.id === invoiceId ? updatedInvoice : inv))
      );

      // Create notification
      if (setNotifications) {
        const notification = createInvoiceSentNotification(
          updatedInvoice,
          () => {
            // Action: View invoice
            // This will be handled by the parent component
          }
        );
        setNotifications((prev) => [notification, ...prev]);
      }

      alert(
        `✅ Herinnering ${reminderNumber} voor factuur ${invoice.invoiceNumber} succesvol verzonden!`
      );
    },
    [invoices, currentUser, employees, setNotifications]
  );

  /**
   * Confirm invoice validation
   */
  const confirmInvoiceValidation = useCallback(() => {
    if (!invoiceToValidate) return;

    const invoice = invoiceToValidate;
    const now = new Date().toISOString();
    const oldStatus = invoice.status;

    // Check if validation modal should be shown
    if (shouldShowValidationModal(invoice)) {
      setShowInvoiceValidationModal(true);
      return;
    }

    // Update invoice status
    const updates: Partial<Invoice> = {
      status: "sent" as const,
      history: [
        ...(invoice.history || []),
        createHistoryEntry(
          "invoice",
          "sent",
          `Status gewijzigd van "${oldStatus}" naar "sent" na validatie door ${getEmployeeName(
            currentUser.employeeId,
            employees
          )}`,
          currentUser,
          { fromStatus: oldStatus, toStatus: "sent" }
        ) as InvoiceHistoryEntry,
      ],
    };

    // Update timestamps
    if (!invoice.timestamps) {
      updates.timestamps = { created: invoice.issueDate };
    } else {
      updates.timestamps = { ...invoice.timestamps };
    }

    if (!updates.timestamps?.sent) {
      updates.timestamps = {
        ...updates.timestamps,
        sent: now,
      };

      // Automatische herinneringsplanning bij verzenden
      if (invoice.dueDate) {
        const dueDate = new Date(invoice.dueDate);
        const reminder1Date = new Date(dueDate);
        reminder1Date.setDate(dueDate.getDate() + 7); // +7 dagen na vervaldatum

        const reminder2Date = new Date(dueDate);
        reminder2Date.setDate(dueDate.getDate() + 14); // +14 dagen na vervaldatum

        updates.reminders = {
          reminder1Date: reminder1Date.toISOString().split("T")[0],
          reminder1Sent: false,
          reminder2Date: reminder2Date.toISOString().split("T")[0],
          reminder2Sent: false,
        };
      }

      // Track invoice validation completion
      trackAction(
        currentUser.employeeId,
        currentUser.role,
        ModuleKey.ACCOUNTING,
        "validate_invoice",
        "complete",
        {
          invoiceId: invoice.id,
          invoiceNumber: invoice.invoiceNumber,
          wasAutoGenerated: isAutoGeneratedInvoice(invoice),
        }
      );
    }

    // Update invoice in state
    setInvoices(
      invoices.map((inv) =>
        inv.id === invoice.id ? { ...inv, ...updates } : inv
      )
    );

    // Close modal and reset
    setShowInvoiceValidationModal(false);
    setInvoiceToValidate(null);
    setValidationChecklist({
      hoursChecked: false,
      materialsChecked: false,
      extraWorkAdded: false,
    });

    // Show success message
    alert(
      `✅ Factuur ${invoice.invoiceNumber} succesvol gevalideerd en verzonden!`
    );
  }, [
    invoiceToValidate,
    invoices,
    currentUser,
    employees,
    setInvoices,
    setShowInvoiceValidationModal,
    setInvoiceToValidate,
    setValidationChecklist,
  ]);

  return {
    // Modal state
    showInvoiceForm,
    setShowInvoiceForm,
    showCloneInvoiceModal,
    setShowCloneInvoiceModal,
    showInvoiceValidationModal,
    setShowInvoiceValidationModal,
    invoiceToValidate,
    setInvoiceToValidate,
    validationChecklist,
    setValidationChecklist,

    // Form (from useInvoiceForm)
    invoiceForm,

    // Handlers
    createInvoice: createInvoiceHandler,
    editInvoice,
    updateInvoiceStatus,
    deleteInvoice,
    cloneInvoice: cloneInvoiceHandler,
    saveClonedInvoice,
    sendReminder,
    confirmInvoiceValidation,
    generateInvoiceNumber,
  };
};


// features/accounting/services/invoiceWorkflowService.ts - Refactored < 250 lines
import type { Invoice, InvoiceHistoryEntry, WorkOrder, User, Employee } from '../../../types';
import { createHistoryEntry, getEmployeeName, isAutoGeneratedInvoice } from '../utils/helpers';
import { validateInvoiceToWorkOrder } from '../../../utils/workflowValidation';

/**
 * Convert invoice to work order
 * @param invoice - Invoice to convert
 * @param currentUser - Current user
 * @param employees - Array of employees
 * @param workOrders - Array of work orders (for validation)
 * @returns Work order data object
 */
export const convertInvoiceToWorkOrder = (
  invoice: Invoice,
  currentUser: User,
  employees: Employee[],
  workOrders: WorkOrder[] = []
): { workOrderData: Partial<WorkOrder>; updatedInvoice: Invoice } => {
  // Validate conversion
  const validation = validateInvoiceToWorkOrder(invoice, workOrders);
  if (!validation.canProceed) {
    throw new Error(validation.message);
  }

  const totalHours = invoice.labor?.reduce((sum, labor) => sum + labor.hours, 0) || 0;
  const now = new Date().toISOString();

  // Update invoice with conversion timestamp
  const updatedInvoice: Invoice = {
    ...invoice,
    timestamps: {
      ...invoice.timestamps,
      convertedToWorkOrder: now,
    },
    history: [
      ...(invoice.history || []),
      createHistoryEntry(
        'invoice',
        'converted_to_workorder',
        `Geconverteerd naar werkorder door ${getEmployeeName(currentUser.employeeId, employees)}`,
        currentUser
      ) as InvoiceHistoryEntry,
    ],
  };

  // Prepare work order data
  const workOrderData: Partial<WorkOrder> = {
    customerId: invoice.customerId,
    invoiceId: invoice.id,
    requiredInventory: invoice.items
      .filter((item) => item.inventoryItemId)
      .map((item) => ({
        itemId: item.inventoryItemId!,
        quantity: item.quantity,
      })),
    estimatedHours: totalHours,
    estimatedCost: invoice.total,
    notes: `Geschatte uren: ${totalHours}u\nGeschatte kosten: €${invoice.total.toFixed(2)}`,
  };

  return { workOrderData, updatedInvoice };
};

/**
 * Sync invoice data to work order
 * @param invoice - Invoice to sync
 * @param workOrder - Work order to update
 * @returns Updated work order object or null if sync not possible
 */
export const syncInvoiceToWorkOrder = (invoice: Invoice, workOrder: WorkOrder): WorkOrder | null => {
  // Check if workorder is completed
  if (workOrder.status === 'Completed') {
    return null; // Cannot sync completed work orders
  }

  // Calculate total hours
  const totalHours = invoice.labor?.reduce((sum, labor) => sum + labor.hours, 0) || 0;

  // Update workorder with new data from invoice
  const updatedWorkOrder: WorkOrder = {
    ...workOrder,
    requiredInventory: invoice.items
      .filter((item) => item.inventoryItemId)
      .map((item) => ({
        itemId: item.inventoryItemId!,
        quantity: item.quantity,
      })),
    estimatedHours: totalHours,
    estimatedCost: invoice.total,
    notes: `${workOrder.notes || ''}\n\n[Update: ${new Date().toLocaleDateString()}] Factuur aangepast - Geschatte uren: ${totalHours}u, Kosten: €${invoice.total.toFixed(
      2
    )}`,
  };

  return updatedWorkOrder;
};

/**
 * Send reminder for invoice
 * @param invoice - Invoice to send reminder for
 * @param reminderNumber - Reminder number (1 or 2)
 * @param currentUser - Current user
 * @param employees - Array of employees
 * @returns Updated invoice object
 */
export const sendInvoiceReminder = (
  invoice: Invoice,
  reminderNumber: 1 | 2,
  currentUser: User,
  employees: Employee[]
): Invoice => {
  if (!invoice.reminders) {
    throw new Error('Invoice has no reminders configured');
  }

  const now = new Date().toISOString();
  const reminderField = reminderNumber === 1 ? 'reminder1Sent' : 'reminder2Sent';
  const reminderDateField = reminderNumber === 1 ? 'reminder1SentDate' : 'reminder2SentDate';

  const updatedInvoice: Invoice = {
    ...invoice,
    reminders: {
      ...invoice.reminders,
      [reminderField]: true,
      [reminderDateField]: now,
    },
    history: [
      ...(invoice.history || []),
      createHistoryEntry(
        'invoice',
        'updated',
        `Herinnering ${reminderNumber} verzonden voor factuur ${invoice.invoiceNumber} door ${getEmployeeName(
          currentUser.employeeId,
          employees
        )}`,
        currentUser
      ) as InvoiceHistoryEntry,
    ],
  };

  return updatedInvoice;
};

/**
 * Validate invoice before sending (for auto-generated invoices)
 * @param invoice - Invoice to validate
 * @returns True if invoice should show validation modal
 */
export const shouldShowValidationModal = (invoice: Invoice): boolean => {
  return invoice.status === 'draft' && isAutoGeneratedInvoice(invoice);
};
